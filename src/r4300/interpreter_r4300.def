/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *   Mupen64plus - interpreter_r4300.def                                   *
 *   Mupen64Plus homepage: http://code.google.com/p/mupen64plus/           *
 *   Copyright (C) 2002 Hacktarux                                          *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include <stdint.h>

static inline unsigned int bshift(uint32_t address)
{
    return ((address & 3) ^ 3) << 3;
}

static inline unsigned int hshift(uint32_t address)
{
    return ((address & 2) ^ 2) << 3;
}


static int readb(uint32_t address, int64_t* value)
{
    uint32_t w;
    unsigned shift = bshift(address);
    int result = read_word(address, &w);
    *value = (w >> shift) & 0xff;

    return result;
}

static int readh(uint32_t address, int64_t* value)
{
    uint32_t w;
    unsigned shift = hshift(address);
    int result = read_word(address, &w);
    *value = (w >> shift) & 0xffff;

    return result;
}

static int readw(uint32_t address, int64_t* value)
{
    uint32_t w;
    int result = read_word(address, &w);
    *value = w;

    return result;
}

static int readd(uint32_t address, int64_t* value)
{
    uint32_t w[2];

    int result = read_word(address    , &w[0]);
                 read_word(address + 4, &w[1]);

    *value = ((uint64_t)w[0] << 32) | w[1];

    return result;
}

static int writeb(uint32_t address, uint8_t value)
{
    unsigned int shift = bshift(address);
    uint32_t w = (uint32_t)value << shift;
    uint32_t mask = (uint32_t)0xff << shift;

    return write_word(address, w, mask);
}

static int writeh(uint32_t address, uint16_t value)
{
    unsigned int shift = hshift(address);
    uint32_t w = (uint32_t)value << shift;
    uint32_t mask = (uint32_t)0xffff << shift;

    return write_word(address, w, mask);
}

static int writew(uint32_t address, uint32_t value)
{
    return write_word(address, value, ~0U);
}

static int writed(uint32_t address, uint64_t value)
{
    int result = writew(address    , value >> 32);
                 writew(address + 4, value      );

    return result;
}

static int write_dword(uint32_t address, uint64_t value, uint64_t mask)
{
    address &= ~7;

    int result = write_word(address    , value >> 32, mask >> 32);
                 write_word(address + 4, value      , mask      );

    return result;
}


DECLARE_JUMP(J,   (PC->f.j.inst_index<<2) | ((PCADDR+4) & 0xF0000000), 1, &reg[0],  0, 0)
DECLARE_JUMP(JAL, (PC->f.j.inst_index<<2) | ((PCADDR+4) & 0xF0000000), 1, &reg[31], 0, 0)
DECLARE_JUMP(BEQ,     PCADDR + (iimmediate+1)*4, irs == irt, &reg[0], 0, 0)
DECLARE_JUMP(BNE,     PCADDR + (iimmediate+1)*4, irs != irt, &reg[0], 0, 0)
DECLARE_JUMP(BLEZ,    PCADDR + (iimmediate+1)*4, irs <= 0,   &reg[0], 0, 0)
DECLARE_JUMP(BGTZ,    PCADDR + (iimmediate+1)*4, irs > 0,    &reg[0], 0, 0)

DECLARE_INSTRUCTION(ADDI)
{
   irt32 = irs32 + iimmediate;
   sign_extended(irt);
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ADDIU)
{
   irt32 = irs32 + iimmediate;
   sign_extended(irt);
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLTI)
{
   if (irs < iimmediate) irt = 1;
   else irt = 0;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(SLTIU)
{
   if ((unsigned long long)irs < (unsigned long long)((long long)iimmediate))
     irt = 1;
   else irt = 0;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ANDI)
{
   irt = irs & (unsigned short)iimmediate;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(ORI)
{
   irt = irs | (unsigned short)iimmediate;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(XORI)
{
   irt = irs ^ (unsigned short)iimmediate;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(LUI)
{
   irt32 = iimmediate << 16;
   sign_extended(irt);
   ADD_TO_PC(1);
}

DECLARE_JUMP(BEQL,    PCADDR + (iimmediate+1)*4, irs == irt, &reg[0], 1, 0)
DECLARE_JUMP(BNEL,    PCADDR + (iimmediate+1)*4, irs != irt, &reg[0], 1, 0)
DECLARE_JUMP(BLEZL,   PCADDR + (iimmediate+1)*4, irs <= 0,   &reg[0], 1, 0)
DECLARE_JUMP(BGTZL,   PCADDR + (iimmediate+1)*4, irs > 0,    &reg[0], 1, 0)

DECLARE_INSTRUCTION(DADDI)
{
   irt = irs + iimmediate;
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(DADDIU)
{
   irt = irs + iimmediate;
   ADD_TO_PC(1);
}

// TODOXXX refactor the following functions to remove the
// lsaddr and lsrpt locals. this may lead to a small speedup too
DECLARE_INSTRUCTION(LDL)
{
    uint64_t d;
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readd(address & ~0x7, (int64_t*)&d) == 0)
    {
        switch(address & 7)
        {
        case 0:
            *lsrtp = d;
            break;
        case 1:
            *lsrtp = (*lsrtp & 0xff) | (d << 8);
            break;
        case 2:
            *lsrtp = (*lsrtp & 0xffff) | (d << 16);
            break;
        case 3:
            *lsrtp = (*lsrtp & 0xffffff) | (d << 24);
            break;
        case 4:
            *lsrtp = (*lsrtp & 0xffffffff) | (d << 32);
            break;
        case 5:
            *lsrtp = (*lsrtp & 0xffffffffffLL) | (d << 40);
            break;
        case 6:
            *lsrtp = (*lsrtp & 0xffffffffffffLL) | (d << 48);
            break;
        case 7:
            *lsrtp = (*lsrtp & 0xffffffffffffffLL) | (d << 56);
            break;
        }
    }
}

DECLARE_INSTRUCTION(LDR)
{
    uint64_t d;
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readd(address & ~0x7, (int64_t*)&d) == 0)
    {
        switch(address & 7)
        {
        case 0:
            *lsrtp = (*lsrtp & 0xffffffffffffff00LL) | (d >> 56);
            break;
        case 1:
            *lsrtp = (*lsrtp & 0xffffffffffff0000LL) | (d >> 48);
            break;
        case 2:
            *lsrtp = (*lsrtp & 0xffffffffff000000LL) | (d >> 40);
            break;
        case 3:
            *lsrtp = (*lsrtp & 0xffffffff00000000LL) | (d >> 32);
            break;
        case 4:
            *lsrtp = (*lsrtp & 0xffffff0000000000LL) | (d >> 24);
            break;
        case 5:
            *lsrtp = (*lsrtp & 0xffff000000000000LL) | (d >> 16);
            break;
        case 6:
            *lsrtp = (*lsrtp & 0xff00000000000000LL) | (d >> 8);
            break;
        case 7:
            *lsrtp = d;
            break;
        }
    }
}

DECLARE_INSTRUCTION(LB)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readb(address, lsrtp) == 0)
        sign_extendedb(*lsrtp);
}

DECLARE_INSTRUCTION(LH)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readh(address, lsrtp) == 0)
        sign_extendedh(*lsrtp);
}

DECLARE_INSTRUCTION(LWL)
{
    uint32_t w;
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (read_word(address, &w) == 0)
    {
        switch((address & 3))
        {
        case 0:
            *lsrtp = w;
            break;

        case 1:
            *lsrtp = (*lsrtp & 0xff) | (w << 8);
            break;

        case 2:
            *lsrtp = (*lsrtp & 0xffff) | (w << 16);
            break;

        case 3:
            *lsrtp = (*lsrtp & 0xffffff) | (w << 24);
            break;
        }

        sign_extended(*lsrtp);
    }
}

DECLARE_INSTRUCTION(LW)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readw(address, lsrtp) == 0)
        sign_extended(*lsrtp);
}

DECLARE_INSTRUCTION(LBU)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    readb(address, lsrtp);
}

DECLARE_INSTRUCTION(LHU)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    readh(address, lsrtp);
}

DECLARE_INSTRUCTION(LWR)
{
    uint32_t w;
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (read_word(address, &w) == 0)
    {
        switch((address & 3))
        {
        case 0:
            *lsrtp = (*lsrtp & ~0xffLL) | ((w >> 24) & 0xff);
            break;

        case 1:
            *lsrtp = (*lsrtp & ~0xffffLL) | ((w >> 16) & 0xffff);
            break;

        case 2:
            *lsrtp = (*lsrtp & ~0xffffffLL) | ((w >> 8) & 0xffffff);
            break;

        case 3:
            *lsrtp = w;
            sign_extended(*lsrtp);
            break;
        }
    }
}

DECLARE_INSTRUCTION(LWU)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    readw(address, lsrtp);
}

DECLARE_INSTRUCTION(SB)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    writeb(address, (*lsrtp & 0xff));
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SH)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    writeh(address, (*lsrtp & 0xffff));
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SWL)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    switch((address & 3))
    {
    case 0:
        write_word(address, (uint32_t)*lsrtp, ~0U);
        break;

    case 1:
        write_word(address, ((uint32_t)*lsrtp >> 8), 0x00ffffff);
        break;

    case 2:
        write_word(address, ((uint32_t)*lsrtp >> 16), 0x0000ffff);
        break;

    case 3:
        write_word(address, ((uint32_t)*lsrtp >> 24), 0x000000ff);
        break;
    }

    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SW)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    writew(address, (*lsrtp & 0xffffffff));
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SDL)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    switch(address & 7)
    {
    case 0:
        writed(address, *lsrtp);
        break;
    case 1:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 8), 0x00ffffffffffffffLL);
        break;
    case 2:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 16), 0x0000ffffffffffffLL);
        break;
    case 3:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 24), 0x000000ffffffffffLL);
        break;
    case 4:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 32), 0x00000000ffffffffLL);
        break;
    case 5:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 40), 0x0000000000ffffffLL);
        break;
    case 6:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 48), 0x000000000000ffffLL);
        break;
    case 7:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp >> 56), 0x00000000000000ffLL);
        break;
    }

    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SDR)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    switch(address & 7)
    {
    case 0:
        write_dword(address, ((uint64_t)*lsrtp << 56), 0xff00000000000000LL);
        break;
    case 1:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp << 48), 0xffff000000000000LL);
        break;
    case 2:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp << 40), 0xffffff0000000000LL);
        break;
    case 3:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp << 32), 0xffffffff00000000LL);
        break;
    case 4:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp << 24), 0xffffffffff000000LL);
        break;
    case 5:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp << 16), 0xffffffffffff0000LL);
        break;
    case 6:
        write_dword(address & ~0x7, ((uint64_t)*lsrtp <<  8), 0xffffffffffffff00LL);
        break;
    case 7:
        writed(address & ~0x7, *lsrtp);
        break;
    }

    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SWR)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    switch((address & 3))
    {
    case 0:
        write_word(address, ((uint32_t)*lsrtp << 24), 0xff000000);
        break;

    case 1:
        write_word(address, ((uint32_t)*lsrtp << 16), 0xffff0000);
        break;

    case 2:
        write_word(address, ((uint32_t)*lsrtp << 8), 0xffffff00);
        break;

    case 3:
        write_word(address, (uint32_t)*lsrtp, ~0U);
        break;
    }

    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(CACHE)
{
   ADD_TO_PC(1);
}

DECLARE_INSTRUCTION(LL)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (readw(address, lsrtp) == 0)
    {
        sign_extended(*lsrtp);
        llbit = 1;
    }
}

DECLARE_INSTRUCTION(LWC1)
{
    uint32_t address = (uint32_t)(lfoffset + reg[lfbase]);
    int64_t tmp;

    if (check_cop1_unusable())
        return;

    ADD_TO_PC(1);

    if (readw(address, &tmp) == 0)
        *((int*)reg_cop1_simple[lfft]) = (int)tmp;
}

DECLARE_INSTRUCTION(LDC1)
{
    uint32_t address = (uint32_t)(lfoffset + reg[lfbase]);

    if (check_cop1_unusable())
        return;

    ADD_TO_PC(1);

    readd(address & ~0x7, (int64_t*)reg_cop1_double[lfft]);
}

DECLARE_INSTRUCTION(LD)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    readd(address & ~0x7, lsrtp);
}

DECLARE_INSTRUCTION(SC)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    if (llbit)
    {
        writew(address, *lsrtp & 0xffffffff);
        CHECK_MEMORY();
        llbit = 0;
        *lsrtp = 1;
    }
    else
    {
        *lsrtp = 0;
    }
}

DECLARE_INSTRUCTION(SWC1)
{
    uint32_t address = (uint32_t)(lfoffset + reg[lfbase]);

    if (check_cop1_unusable())
        return;

    ADD_TO_PC(1);

    writew(address, *(uint32_t*)reg_cop1_simple[lfft]);
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SDC1)
{
    uint32_t address = (uint32_t)(lfoffset + reg[lfbase]);

    if (check_cop1_unusable())
        return;

    ADD_TO_PC(1);

    writed(address & ~0x7, *(uint64_t*)reg_cop1_double[lfft]);
    CHECK_MEMORY();
}

DECLARE_INSTRUCTION(SD)
{
    uint32_t address = (uint32_t)(iimmediate + irs32);
    int64_t* lsrtp = (int64_t*)(PC->f.i.rt);

    ADD_TO_PC(1);

    writed(address & ~0x7, *lsrtp);
    CHECK_MEMORY();
}

